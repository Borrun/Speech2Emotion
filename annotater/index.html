<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Speech2Emotion Curve Annotator</title>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    .left { border-right: 1px solid #ddd; overflow: auto; }
    .right { padding: 14px 18px; }
    .hdr { padding: 12px 12px; border-bottom: 1px solid #eee; display:flex; gap:10px; align-items:center; }
    .hdr b { font-size: 14px; }
    .list { padding: 0; margin: 0; list-style: none; }
    .item { padding: 10px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
    .item:hover { background: #fafafa; }
    .item.active { background: #eef6ff; }
    .meta { font-size: 12px; color: #666; margin-top: 4px; display:flex; gap:10px; flex-wrap:wrap;}
    .pill { font-size: 12px; padding: 2px 6px; border-radius: 999px; background:#f3f3f3; display:inline-block; }
    .pill.ok { background:#e6f7e6; }
    .pill.no { background:#ffecec; }

    #waveBox { border: 1px solid #ddd; border-radius: 10px; padding: 10px; position: relative; }
    #wave { position: relative; }
    #overlay {
      position:absolute; left:10px; right:10px;
      top:10px;
      height:160px;
      z-index: 5;
    }
    #overlay svg { width:100%; height:100%; display:block; }

    .controls { margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button, select, input { font: inherit; }
    button { padding: 8px 10px; border: 1px solid #ccc; background:#fff; border-radius: 8px; cursor:pointer; }
    button:hover { background:#fafafa; }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .muted { color:#666; }
    .danger { color:#b00020; }
    .panel {
      margin-top: 10px;
      border:1px solid #eee; border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .panel .full { grid-column: 1 / -1; }
    .hint { font-size: 12px; color:#666; line-height: 1.4; }
    select { padding:6px 8px; border:1px solid #ddd; border-radius: 8px; }
    textarea { width:100%; min-height: 84px; padding:8px 10px; border:1px solid #ddd; border-radius: 10px; resize: vertical; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
           font-size: 12px; border: 1px solid #ddd; padding: 2px 6px; border-radius: 6px; background:#fafafa; }
  
    .legend { display:flex; flex-wrap:wrap; gap:10px; margin-top:8px; }
    .legend .item { display:flex; align-items:center; gap:6px; font-size:12px; color: rgba(0,0,0,0.75); }
    .legend .dot { width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,0.25); }

  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="hdr">
      <b>Files</b>
      <span class="pill" id="countPill">0</span>
      <span class="pill ok" id="donePill">done: 0</span>
    </div>
    <ul class="list" id="fileList"></ul>
  </div>

  <div class="right">
    <div class="row">
      <div><b id="curName">No file</b></div>
      <div class="muted">fps: <b id="fps">30</b></div>
      <div class="muted">duration(s): <b id="dur">—</b></div>
      <div class="muted">curve pts: <b id="ptCount">—</b></div>
      <div class="muted">segment: <b id="segInfo">—</b></div>
    </div>

    <div id="waveBox" style="margin-top:10px">
      <div id="wave"></div>
      <div id="overlay"><svg id="svg"></svg></div>
    </div>

    <div class="controls">
      <button id="btnPlay">Play/Pause <span class="kbd">Space</span></button>
      <button id="btnPrev">Prev <span class="kbd">P</span></button>
      <button id="btnNext">Next <span class="kbd">N</span></button>
      <button id="btnSave">Save</button>
      <button id="btnExport">Export (JSON)</button>
    </div>

    <div class="panel">
      <div class="full">
        <div class="row">
          <div class="muted"><b>点击曲线段修改情绪类型</b></div>
          <select id="segType">
            <option>happy</option><option>sad</option><option>angry</option><option>fear</option>
            <option selected>calm</option><option>confused</option>
          </select>
          <span class="hint">点中某一段（两点之间）后，这一段将被设置为所选 type。</span>
          <div id="typeLegend" class="legend"></div>
        </div>
      </div>

      <div class="full">
        <div class="muted"><b>Audio Text</b>（转写/内容）</div>
        <div style="margin-top:6px">
          <textarea id="audioText" placeholder="可选：输入这段音频的文字内容（会随标注一起保存、导出）"></textarea>
        </div>
      </div>

      <div class="full hint">
        操作：
        <ul>
          <li><b>左键拖动点</b>：调整时间/等级（时间会量化到帧）。</li>
          <li><b>右键点空白处</b>：新增点（会吸附到最近等级线）。</li>
          <li><b>Alt + 左键点</b>：删除该点（首尾端点不可删）；也可先点选点，再按 <span class="kbd">Delete</span>/<span class="kbd">Backspace</span> 删除。</li>
          <li><b>点击曲线段</b>：修改该段情绪类型（按段 piecewise-constant）。</li>
          <li>所有等级变化按“阶梯”显示：一帧突变。</li>
        </ul>
      </div>
    </div>

    <div class="danger" id="err" style="margin-top:10px"></div>
  </div>
</div>

<script>
  const FPS = 30;
  const TYPES = ["happy","sad","angry","fear","calm","confused"];

  let files = [];
  let curIndex = -1;
  let wave = null;

  let duration = null;
  let curve = [];    // [{t,type,value}]

  // drag point
  let draggingIndex = null;
  let dragOffset = {dx:0, dy:0};

  // selection / deletion
  let selectedIndex = null; // selected control point index (for Delete key)
  let hoveredSeg = null; // hovered segment index
  let selectedSeg = null; // clicked/selected segment index

  // DOM
  const elList = document.getElementById('fileList');
  const elName = document.getElementById('curName');
  const elFps = document.getElementById('fps');
  const elDur = document.getElementById('dur');
  const elPtCount = document.getElementById('ptCount');
  const elSegInfo = document.getElementById('segInfo');
  const elErr = document.getElementById('err');
  const elCount = document.getElementById('countPill');
  const elDone = document.getElementById('donePill');

  const svg = document.getElementById('svg');
  const waveBox = document.getElementById('waveBox');

  const segTypeEl = document.getElementById('segType');
  const audioTextEl = document.getElementById('audioText');

  function renderTypeLegend(){
    const lg = document.getElementById("typeLegend");
    if(!lg) return;
    lg.innerHTML = "";
    const types = ["happy","sad","angry","fear","calm","confused"];
    for(const ty of types){
      const it = document.createElement("div");
      it.className = "item";
      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = typeColor(ty);
      it.appendChild(dot);
      const tx = document.createElement("span");
      tx.textContent = ty;
      it.appendChild(tx);
      lg.appendChild(it);
    }
  }
  renderTypeLegend();


  function setErr(msg){ elErr.textContent = msg || ""; }

  async function fetchJSON(url, opts){
    const res = await fetch(url, opts);
    if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  }

  function clamp(v, lo, hi){
    v = Number(v);
    if(!Number.isFinite(v)) v = lo;
    return Math.max(lo, Math.min(hi, v));
  }

  // Global "level snapping" (阶级粘滞): map any value to the CENTER of its bucket.
  const LEVEL_BUCKETS = [
    {lvl:0, lo:0,   hi:10,  mid:5},
    {lvl:1, lo:11,  hi:25,  mid:18},
    {lvl:2, lo:26,  hi:50,  mid:38},
    {lvl:3, lo:51,  hi:85,  mid:68},
    {lvl:4, lo:86,  hi:110, mid:98},
    {lvl:5, lo:111, hi:150, mid:130},
  ];
  const HYSTERESIS = 3; 

  // Segment type visualization colors (用于曲线段显示)
  const TYPE_COLORS = {
    happy: "#f6a21a",
    sad: "#5b7bd5",
    angry: "#d64545",
    fear: "#7a5bd5",
    calm: "#2e8b57",
    confused: "#7a7a7a",
  };
  function typeColor(ty){
    const k = normType(ty);
    return TYPE_COLORS[k] || "#0b57d0";
  }
// value-units; increase if you want "stickier"

  function bucketOf(v){
    v = clamp(v, 0, 150);
    for(let i=LEVEL_BUCKETS.length-1;i>=0;i--){
      const b = LEVEL_BUCKETS[i];
      if(v>=b.lo && v<=b.hi) return b;
    }
    return LEVEL_BUCKETS[0];
  }

  function snapToLevels(v, currentV){
    v = clamp(v, 0, 150);
    if(currentV!==undefined && currentV!==null && !Number.isNaN(Number(currentV))){
      const curB = bucketOf(Number(currentV));
      if(v >= (curB.lo - HYSTERESIS) && v <= (curB.hi + HYSTERESIS)){
        return curB.mid;
      }
    }
    return bucketOf(v).mid;
  }

  function normType(t){
    t = (t||"").toLowerCase().trim();
    return TYPES.includes(t) ? t : "calm";
  }

  function ensureWave(){
    return !!wave && curIndex >= 0 && duration != null;
  }

  function overlayRect(){
    return document.getElementById('overlay').getBoundingClientRect();
  }

  function tToX(t){
    const r = overlayRect();
    const w = r.width;
    const pct = duration > 0 ? (t / duration) : 0;
    return clamp(pct,0,1)*w;
  }
  function xToT(x){
    const r = overlayRect();
    const w = r.width;
    const pct = w>0 ? (x/w) : 0;
    return clamp(pct,0,1)*duration;
  }
  function vToY(v){
    const r = overlayRect();
    const h = r.height;
    const pct = 1 - (clamp(v,0,150)/150);
    return clamp(pct,0,1)*h;
  }
  function yToV(y){
    const r = overlayRect();
    const h = r.height;
    const pct = h>0 ? (y/h) : 1;
    return clamp((1-clamp(pct,0,1))*150,0,150);
  }

  function sortCurve(){
    curve.sort((a,b)=>a.t-b.t);
  }

  function quantT(t){
    return Math.round(Number(t) * FPS) / FPS;
  }

  function normalizeCurveEndpoints(){
    if(!duration) return;
    if(!curve || curve.length<2){
      const v = snapToLevels(60);
      curve = [
        {t:0, type:"calm", value:v},
        {t:duration, type:"calm", value:v},
      ];
    }
    sortCurve();
    curve[0].t = 0;
    curve[curve.length-1].t = duration;
  }

  function pointIndexAtT(t){
    const tq = Number(t);
    for(let i=0;i<curve.length;i++){
      if(Math.abs(Number(curve[i].t) - tq) < 1e-9) return i;
    }
    return -1;
  }

  // Staircase (left-constant) value/type lookup
  function valueAtStep(t){
    if(!curve || curve.length===0) return snapToLevels(60);
    if(t<=curve[0].t) return curve[0].value;
    for(let i=0;i<curve.length-1;i++){
      if(curve[i].t <= t && t < curve[i+1].t) return curve[i].value;
    }
    return curve[curve.length-1].value;
  }
  function typeAt(t){
    if(!curve || curve.length===0) return "calm";
    if(t<=curve[0].t) return curve[0].type;
    for(let i=0;i<curve.length-1;i++){
      if(curve[i].t <= t && t < curve[i+1].t) return curve[i].type;
    }
    return curve[curve.length-1].type;
  }

  // Insert a control point at time t (quantized to frame grid).
  // If this point changes level, ensure a "hold" point at (k-1)/FPS exists, so it's a one-frame jump.
  function insertCurvePoint(t, value, ty){
    if(!ensureWave()) return;
    const tQ = quantT(clamp(t, 0, duration));
    const k = Math.round(tQ * FPS);
    const kEnd = Math.round(duration * FPS);

    // Don't overwrite hard endpoints
    if(k <= 0 || k >= kEnd) return;

    const oldV = valueAtStep(tQ);
    const oldTy = typeAt(tQ);
    const newV = snapToLevels(clamp(value,0,150), oldV);
    const newTy = normType(ty || oldTy);

    if(Math.abs(newV - oldV) > 1e-6){
      const tHold = (k-1) / FPS;
      if(pointIndexAtT(tHold) < 0){
        curve.push({t:tHold, type: oldTy, value: oldV});
      }
    }

    const idx = pointIndexAtT(tQ);
    if(idx >= 0){
      curve[idx].type = newTy;
      curve[idx].value = newV;
    } else {
      curve.push({t:tQ, type: newTy, value: newV});
    }

    sortCurve();
    // dedup same t (keep last)
    const ded = [];
    for(const p of curve){
      if(ded.length && Math.abs(ded[ded.length-1].t - p.t) < 1e-9) ded[ded.length-1] = p;
      else ded.push(p);
    }
    curve = ded;

    normalizeCurveEndpoints();
  }

  function cleanupCurve(){
    if(!curve || curve.length<2) return;
    sortCurve();

    // Dedup same-t (keep last)
    const ded = [];
    for(const p of curve){
      if(ded.length && Math.abs(ded[ded.length-1].t - p.t) < 1e-9) ded[ded.length-1] = p;
      else ded.push(p);
    }
    curve = ded;

    // Remove redundant interior points that do not change value/type (staircase semantics)
    if(curve.length > 2){
      const keep = [curve[0]];
      for(let i=1;i<curve.length-1;i++){
        const prev = keep[keep.length-1];
        const cur = curve[i];
        if(Math.abs(Number(cur.value) - Number(prev.value)) < 1e-9 && normType(cur.type) === normType(prev.type)){
          continue; // redundant
        }
        keep.push(cur);
      }
      keep.push(curve[curve.length-1]);
      curve = keep;
    }

    normalizeCurveEndpoints();
  }

  function deletePoint(idx){
    if(!ensureWave()) return false;
    if(idx==null) return false;
    idx = Number(idx);
    if(!Number.isInteger(idx)) return false;
    if(!curve || curve.length < 3) return false; // keep at least endpoints
    if(idx <= 0 || idx >= curve.length-1) return false; // don't delete endpoints

    curve.splice(idx, 1);
    selectedIndex = null;
    // adjust selected segment index if needed
    if(selectedSeg!=null){
      if(selectedSeg === idx) selectedSeg = null;
      else if(selectedSeg > idx) selectedSeg -= 1;
    }
    cleanupCurve();
    return true;
  }

  // Apply type to a time interval (segment semantics): [t0, t1)
  function applyTypeToInterval(t0, t1, ty){
    if(!ensureWave()) return;
    const a0 = quantT(Math.min(t0, t1));
    const a1 = quantT(Math.max(t0, t1));
    if(a1 <= a0 + 1e-9) return;

    const newTy = normType(ty);

    // Ensure boundary points exist
    const v0 = valueAtStep(a0);
    const v1 = valueAtStep(a1);
    curve.push({t:a0, type:typeAt(a0), value:v0});
    curve.push({t:a1, type:typeAt(a1), value:v1});
    sortCurve();

    const ded = [];
    for(const p of curve){
      if(ded.length && Math.abs(ded[ded.length-1].t - p.t) < 1e-9) ded[ded.length-1] = p;
      else ded.push(p);
    }
    curve = ded;

    for(const p of curve){
      if(p.t >= a0 - 1e-9 && p.t < a1 - 1e-9){
        p.type = newTy;
      }
    }

    normalizeCurveEndpoints();
    draw();
    saveLabel().catch(err=>setErr(String(err)));
  }

  function renderList(){
    elList.innerHTML = "";
    let done=0;
    files.forEach((f,i)=>{
      const li=document.createElement('li');
      li.className='item'+(i===curIndex?' active':'');
      if(f.labeled) done++;
      li.innerHTML = `
        <div><b>${f.wav}</b></div>
        <div class="meta">
          <span class="pill ${f.labeled?'ok':'no'}">${f.labeled?'labeled':'unlabeled'}</span>
        </div>
      `;
      li.onclick=()=>loadIndex(i);
      elList.appendChild(li);
    });
    elCount.textContent = files.length;
    elDone.textContent = `done: ${done}`;
  }

  function updateHeader(){
    const f = (curIndex>=0)?files[curIndex]:null;
    elName.textContent = f?f.wav:"No file";
    elFps.textContent = FPS;
    elDur.textContent = (duration==null)?"—":duration.toFixed(3);
    elPtCount.textContent = curve?String(curve.length):"—";

    let segTxt = "—";
    const segIdx = (selectedSeg!=null) ? selectedSeg : hoveredSeg;
    if(segIdx!=null && curve && segIdx>=0 && segIdx < curve.length-1){
      const ty = normType(curve[segIdx].type);
      segTxt = `${segIdx} (${ty})`;
      if(selectedSeg==null && hoveredSeg!=null) segTxt = `hover ${segTxt}`;
    }
    if(elSegInfo) elSegInfo.textContent = segTxt;
  }

  function destroyWave(){
    if(wave){ wave.destroy(); wave=null; }
    document.getElementById('wave').innerHTML="";
    svg.innerHTML="";
    duration=null;
    draggingIndex=null;
  }

  function draw(){
    svg.innerHTML = "";
    if(!ensureWave()) return;

    const r = overlayRect();
    const w=r.width, h=r.height;

    // bg
    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0");
    bg.setAttribute("width",String(w)); bg.setAttribute("height",String(h));
    bg.setAttribute("fill","rgba(0,0,0,0.02)");
    svg.appendChild(bg);

    // Level guide lines (dashed)
    for(const b of LEVEL_BUCKETS){
      const y = vToY(b.mid);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1","0"); ln.setAttribute("x2",String(w));
      ln.setAttribute("y1",String(y)); ln.setAttribute("y2",String(y));
      ln.setAttribute("stroke","rgba(0,0,0,0.18)");
      ln.setAttribute("stroke-dasharray","4 4");
      svg.appendChild(ln);

      const tx = document.createElementNS("http://www.w3.org/2000/svg","text");
      tx.setAttribute("x","4");
      tx.setAttribute("y",String(y-2));
      tx.setAttribute("font-size","11");
      tx.setAttribute("fill","rgba(0,0,0,0.45)");
      tx.style.pointerEvents = "none";
      tx.textContent = `L${b.lvl}`;
      svg.appendChild(tx);
    }

    // Staircase points (for hit testing)
    const stepPts = [];
    if(curve && curve.length){
      stepPts.push({t:curve[0].t, v:curve[0].value});
      for(let i=1;i<curve.length;i++){
        stepPts.push({t:curve[i].t, v:curve[i-1].value});
        stepPts.push({t:curve[i].t, v:curve[i].value});
      }
    }
    const pts = stepPts.map(p=>`${tToX(p.t)},${vToY(p.v)}`).join(" ");

    // Visible segments: draw each horizontal interval with its type color (piecewise-constant)
    if(curve && curve.length>=2){
      for(let i=0;i<curve.length-1;i++){
        const t0 = curve[i].t, t1 = curve[i+1].t;
        const v  = curve[i].value;
        const ty = normType(curve[i].type);

        // horizontal segment (type applies to [t0, t1))
        const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
        ln.setAttribute("x1", String(tToX(t0)));
        ln.setAttribute("y1", String(vToY(v)));
        ln.setAttribute("x2", String(tToX(t1)));
        ln.setAttribute("y2", String(vToY(v)));
        ln.setAttribute("stroke", typeColor(ty));
        ln.setAttribute("stroke-width", (selectedSeg===i) ? "5" : "3");
        ln.setAttribute("stroke-linecap","round");
        ln.style.pointerEvents = "none";
        svg.appendChild(ln);

        // optional label on segment midpoint (helps confirm type at a glance)
        const mx = (tToX(t0) + tToX(t1))/2;
        const my = vToY(v) - 8;
        const label = document.createElementNS("http://www.w3.org/2000/svg","text");
        label.setAttribute("x", String(mx));
        label.setAttribute("y", String(my));
        label.setAttribute("text-anchor","middle");
        label.setAttribute("font-size","10");
        label.setAttribute("fill", "rgba(0,0,0,0.6)");
        label.style.pointerEvents = "none";
        label.textContent = ty;
        svg.appendChild(label);

        // vertical jump indicator (neutral color)
        const v2 = curve[i+1].value;
        const j = document.createElementNS("http://www.w3.org/2000/svg","line");
        j.setAttribute("x1", String(tToX(t1)));
        j.setAttribute("y1", String(vToY(v)));
        j.setAttribute("x2", String(tToX(t1)));
        j.setAttribute("y2", String(vToY(v2)));
        j.setAttribute("stroke","rgba(0,0,0,0.25)");
        j.setAttribute("stroke-width","1");
        j.style.pointerEvents = "none";
        svg.appendChild(j);
      }
    }

    // Invisible, thick hit target to make segment clicking easy
    const plHit = document.createElementNS("http://www.w3.org/2000/svg","polyline");
    plHit.setAttribute("points", pts);
    plHit.setAttribute("fill","none");
    plHit.setAttribute("stroke","rgba(0,0,0,0)"); // fully transparent
    plHit.setAttribute("stroke-width","14");
    plHit.style.pointerEvents = "stroke";
    plHit.style.cursor = "pointer";

    // Hover shows segment info
    plHit.addEventListener("pointermove", (ev)=>{
      if(!ensureWave()) return;
      const o = overlayRect();
      const x = ev.clientX - o.left;
      const t = xToT(x);
      let seg = -1;
      for(let i=0;i<curve.length-1;i++){
        if(curve[i].t <= t && t < curve[i+1].t){ seg=i; break; }
      }
      hoveredSeg = (seg>=0) ? seg : null;
      updateHeader();
    });
    plHit.addEventListener("pointerleave", ()=>{
      hoveredSeg = null;
      updateHeader();
    });

    // Click a segment to change its emotion type (piecewise constant by segment).
    plHit.addEventListener("click", (ev)=>{
      if(!ensureWave()) return;
      const o = overlayRect();
      const x = ev.clientX - o.left;
      const t = xToT(x);

      let seg = -1;
      for(let i=0;i<curve.length-1;i++){
        if(curve[i].t <= t && t < curve[i+1].t){ seg=i; break; }
      }
      if(seg < 0) return;

      selectedSeg = seg;
      applyTypeToInterval(curve[seg].t, curve[seg+1].t, normType(segTypeEl.value));
      ev.preventDefault();
    });

    svg.appendChild(plHit);

    // points
    curve.forEach((p, idx)=>{
      const cx=tToX(p.t), cy=vToY(p.value);

      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "6");
      c.setAttribute("fill", "#fff");
      c.setAttribute("stroke", (selectedIndex===idx) ? "#d00" : "#111");
      c.setAttribute("stroke-width", "1.5");
      c.style.cursor = "grab";
      c.style.pointerEvents = "all";

      c.addEventListener("mousedown", (ev)=>{
        ev.preventDefault(); ev.stopPropagation();
        draggingIndex = idx;
        selectedIndex = idx;

        const o = overlayRect();
        const lx = ev.clientX - o.left;
        const ly = ev.clientY - o.top;
        dragOffset.dx = lx - tToX(curve[idx].t);
        dragOffset.dy = ly - vToY(curve[idx].value);
      });

      c.addEventListener("click", (ev)=>{
        // Alt+LeftClick deletes the point (non-endpoints)
        if(ev.altKey){
          ev.preventDefault(); ev.stopPropagation();
          if(deletePoint(idx)){
            draw();
            saveLabel().catch(err=>setErr(String(err)));
          }
          return;
        }
        // otherwise select for Delete/Backspace key
        selectedIndex = idx;
        draw();
      });

      svg.appendChild(c);
    });

    updateHeader();
  }

  async function saveLabel(){
    if(curIndex<0) return;
    const wav = files[curIndex].wav;
    await fetchJSON('/api/label', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ wav, fps: FPS, duration, curve, text: (audioTextEl?.value || "") })
    });
    files[curIndex].labeled = Array.isArray(curve) && curve.length >= 2;
    renderList();
  }

  async function exportJSON(){
    if(curIndex<0) return;
    await saveLabel();
    const wav = files[curIndex].wav;
    const data = await fetchJSON(`/api/export/${encodeURIComponent(wav)}`);
    const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = wav.replace(/\.wav$/i,"") + ".frames.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function togglePlay(){
    if(!ensureWave()) return;
    wave.playPause();
  }

  async function nextFile(){
    if(files.length===0) return;
    await loadIndex(Math.min(curIndex+1, files.length-1));
  }
  async function prevFile(){
    if(files.length===0) return;
    await loadIndex(Math.max(curIndex-1, 0));
  }

  async function loadFiles(){
    setErr("");
    files = await fetchJSON('/api/files');
    renderList();
    const firstUnlabeled = files.findIndex(f=>!f.labeled);
    await loadIndex(firstUnlabeled>=0 ? firstUnlabeled : (files.length?0:-1));
  }

  async function loadIndex(i){
    if(i<0 || i>=files.length){
      curIndex=-1;
      destroyWave();
      updateHeader();
      return;
    }
    curIndex=i;
    renderList();
    destroyWave();
    setErr("");

    const wav = files[curIndex].wav;


    const audioUrl = `/audio/${encodeURIComponent(wav)}`;
    try {
      const head = await fetch(audioUrl, { method: 'HEAD' });
      if(!head.ok) throw new Error(`${head.status} ${head.statusText}`);
    } catch (e) {
      setErr(`Audio load failed: ${audioUrl}  (${e})\n\nCheck: 1) server started, 2) AUDIO_DIR points to your wav folder, 3) the file exists.`);
      return;
    }

    wave = WaveSurfer.create({
      container:'#wave',
      height:180,
      waveColor:'#8aa',
      progressColor:'#446',
      cursorColor:'#111',
      url: audioUrl,
      normalize:true,
      backend:'WebAudio'
    });

    wave.on('error', (e)=>{
      setErr(`WaveSurfer error: ${e}`);
    });


    wave.on('ready', async ()=>{
      duration = wave.getDuration();
      updateHeader();

      const lbl = await fetchJSON(`/api/label/${encodeURIComponent(wav)}`);
      curve = Array.isArray(lbl.curve) ? lbl.curve : [];

      selectedIndex = null;

      if(audioTextEl){
        audioTextEl.value = (typeof lbl.text === 'string') ? lbl.text : (lbl.text ?? "");
      }

      if(!curve || curve.length<2){
        const v = snapToLevels(60);
        curve = [
          {t:0, type:"calm", value:v},
          {t:duration, type:"calm", value:v},
        ];
      }
      normalizeCurveEndpoints();
      draw();

      await saveLabel();
    });

    // dragging curve points
    window.onmousemove = (ev)=>{
      if(draggingIndex==null) return;
      if(!ensureWave()) return;

      const o = overlayRect();
      const lx = ev.clientX - o.left - dragOffset.dx;
      const ly = ev.clientY - o.top - dragOffset.dy;

      let t = quantT(xToT(lx));
      let v = snapToLevels(yToV(ly), curve[draggingIndex]?.value);

      // lock endpoints
      if(draggingIndex===0) t=0;
      if(draggingIndex===curve.length-1) t=duration;

      curve[draggingIndex].t = t;
      curve[draggingIndex].value = v;

      normalizeCurveEndpoints();
      draw();
    };

    window.onmouseup = ()=>{
      if(draggingIndex!=null){
        draggingIndex=null;
        saveLabel().catch(err=>setErr(String(err)));
      }
    };

    // Right click: add curve control point. Disable default context menu.
    const overlay = document.getElementById('overlay');
    overlay.addEventListener("contextmenu", (ev)=>{ ev.preventDefault(); });

    overlay.addEventListener("mousedown", (ev)=>{
      if(!ensureWave()) return;
      if(ev.button !== 2) return; // right button

      const o = overlayRect();
      const x = ev.clientX - o.left;
      const y = ev.clientY - o.top;

      const t = quantT(xToT(x));
      const v = snapToLevels(yToV(y));
      insertCurvePoint(t, v, typeAt(t));
      draw();
      saveLabel().catch(err=>setErr(String(err)));
      ev.preventDefault();
    });

    updateHeader();
  }

  // Buttons
  document.getElementById('btnPlay').onclick = togglePlay;
  document.getElementById('btnNext').onclick = nextFile;
  document.getElementById('btnPrev').onclick = prevFile;
  document.getElementById('btnSave').onclick = ()=>saveLabel().catch(err=>setErr(String(err)));
  document.getElementById('btnExport').onclick = ()=>exportJSON().catch(err=>setErr(String(err)));

  // Keyboard shortcuts
  document.addEventListener('keydown', async (e)=>{
    if(e.target && ['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
    if(e.code==='Space'){ e.preventDefault(); togglePlay(); return; }
    if(e.key==='n' || e.key==='N'){ await nextFile(); return; }
    if(e.key==='p' || e.key==='P'){ await prevFile(); return; }
    if(e.key==='Delete' || e.key==='Backspace'){
      if(selectedIndex!=null && deletePoint(selectedIndex)){
        draw();
        saveLabel().catch(err=>setErr(String(err)));
      }
      return;
    }
  });

  // init
  loadFiles().catch(err=>setErr(String(err)));</script>
</body>
</html>
