<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Speech2Emotion Curve Annotator</title>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    .left { border-right: 1px solid #ddd; overflow: auto; }
    .right { padding: 14px 18px; overflow:auto; }

    .hdr { padding: 12px 12px; border-bottom: 1px solid #eee; display:flex; gap:10px; align-items:center; }
    .hdr b { font-size: 14px; }
    .list { padding: 0; margin: 0; list-style: none; }
    .item { padding: 10px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
    .item:hover { background: #f7fbff; }
    .item.active { background: #eef6ff; }
    .meta { font-size: 12px; color: #666; margin-top: 4px; display:flex; gap:10px; flex-wrap:wrap;}
    .pill { font-size: 12px; padding: 2px 6px; border-radius: 999px; background:#f3f3f3; display:inline-block; }
    .pill.ok { background:#e6f7e6; }
    .pill.no { background:#ffecec; }

    #waveBox { border: 1px solid #ddd; border-radius: 10px; padding: 10px; position: relative; }
    #wave { position: relative; }
    #overlay {
      position:absolute; left:10px; right:10px;
      top:10px;
      height:160px;
      z-index: 5;
    }
    #overlay svg { width:100%; height:100%; display:block; }

    .controls { margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button, select, input, textarea { font: inherit; }
    button { padding: 8px 10px; border: 1px solid #ccc; border-radius: 8px; background:#fff; cursor:pointer;}
    button:hover { background:#f6f6f6; }
    button.primary { border-color:#0aa; background:#0aa; color:#fff; }
    select, input { padding: 7px 10px; border: 1px solid #ccc; border-radius: 8px; }
    textarea { width: 100%; min-height: 90px; resize: vertical; padding: 10px; border:1px solid #ccc; border-radius: 10px; }

    .kpi { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; font-size: 12px; color:#555;}
    .kpi span { background:#fafafa; border:1px solid #eee; border-radius: 999px; padding: 3px 8px; }
    .err { margin-top: 10px; white-space: pre-wrap; color: #b00; background:#fff5f5; border:1px solid #f2b; border-radius: 10px; padding: 8px 10px; }
    .hint { margin-top: 8px; font-size: 12px; color: #666; line-height: 1.4; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 1px 6px; border: 1px solid #ddd; border-bottom-width: 2px; border-radius: 6px; background:#f8f8f8; }

    .topbar { display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; align-items:center; }
    .topbar .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .sectionTitle { margin: 14px 0 6px; font-size: 13px; color:#333; }
  </style>
</head>
<body>
<div class="wrap">
  <aside class="left">
    <div class="hdr">
      <b>Files</b>
      <span class="pill" id="countPill">0</span>
      <span class="pill" id="donePill">done:0</span>
      <button id="btnReload" style="margin-left:auto;">Reload</button>
    </div>
    <ul class="list" id="fileList"></ul>
  </aside>

  <section class="right">
    <div class="topbar">
      <div class="row">
        <b id="curName">No file</b>
        <span class="pill">fps: <span id="fps">-</span></span>
        <span class="pill">dur: <span id="dur">-</span>s</span>
        <span class="pill">points: <span id="ptCount">0</span></span>
        <span class="pill" id="segInfo">segment: -</span>
      </div>
      <div class="row">
        <button class="primary" id="btnSave">Save <span class="kbd">S</span></button>
        <button id="btnPrev">Prev <span class="kbd">←</span></button>
        <button id="btnNext">Next <span class="kbd">→</span></button>
      </div>
    </div>

    <div id="err" class="err"></div>

    <div id="waveBox" style="margin-top: 10px;">
      <div id="wave"></div>
      <div id="overlay"><svg id="svg"></svg></div>
    </div>

    <div class="controls">
      <button id="btnPlay">Play/Pause <span class="kbd">Space</span></button>

      <label>Type:</label>
      <select id="segType">
        <option value="calm">calm</option>
        <option value="happy">happy</option>
        <option value="sad">sad</option>
        <option value="angry">angry</option>
        <option value="fear">fear</option>
        <option value="confused">confused</option>
      </select>

      <label>FPS:</label>
      <input id="fpsInput" type="number" min="1" max="300" step="1" value="100" style="width: 90px;" />

      <button id="btnExport">Export (JSON)</button>
      <button id="btnGenerate">Generate</button>
    </div>

    <div class="kpi" id="kpi"></div>

    <div class="sectionTitle">Text / Transcript</div>
    <textarea id="textBox" placeholder="可选：输入转写、备注、说话内容等（随标签保存）"></textarea>

    <div class="hint">
      交互：
      <span class="kbd">左键拖动</span> 调整点（吸附等级虚线；跳变处上下两点共享时间，水平拖动会一起移动）；
      <span class="kbd">右键</span> 在光标处新增点；
      <span class="kbd">Alt+左键</span> 删除内部跳变点；
      <span class="kbd">点击曲线段</span> 将该段情绪类型设置为当前下拉框类型；
      <span class="kbd">Space</span> 播放/暂停。
    </div>
  </section>
</div>

<script>
  let FPS = 100; // default: 16kHz / 160-sample hop = 100 fps
  const DEFAULT_SAMPLE_RATE = 16000;
  const DEFAULT_HOP_SAMPLES = 160;

  const TYPES = ["happy","sad","angry","fear","calm","confused"];

  // (lvl, lo, hi, mid) in 0..150
  const LEVEL_BUCKETS = [
    {lvl:0, lo:0,   hi:10,  mid:5},
    {lvl:1, lo:11,  hi:25,  mid:18},
    {lvl:2, lo:26,  hi:50,  mid:38},
    {lvl:3, lo:51,  hi:85,  mid:68},
    {lvl:4, lo:86,  hi:110, mid:98},
    {lvl:5, lo:111, hi:150, mid:130},
  ];

  const TYPE_COL = {
    happy: "#f4b000",
    sad: "#3b82f6",
    angry: "#ef4444",
    fear: "#8b5cf6",
    calm: "#10b981",
    confused: "#6b7280",
  };

  let files = [];
  let curIndex = -1;
  let wave = null;

  let duration = null;
  let curve = [];    // [{t,type,value}]  step curve
  let draggingHandle = null; // {boundaryIdx, curveIdxValue, role}
  let dragOffset = {dx:0, dy:0};

  let selectedIndex = null; // selected boundary index (for Delete)
  let hoveredSeg = null;
  let selectedSeg = null;

  const elList = document.getElementById('fileList');
  const elName = document.getElementById('curName');
  const elFps = document.getElementById('fps');
  const elDur = document.getElementById('dur');
  const elPtCount = document.getElementById('ptCount');
  const elSegInfo = document.getElementById('segInfo');
  const elErr = document.getElementById('err');
  const elCount = document.getElementById('countPill');
  const elDone = document.getElementById('donePill');
  const elKpi = document.getElementById('kpi');

  const segTypeEl = document.getElementById('segType');
  const fpsInput = document.getElementById('fpsInput');
  const textBox = document.getElementById('textBox');

  const svg = document.getElementById('svg');

  function setErr(msg){ elErr.textContent = msg || ""; }

  async function fetchJSON(url, opts){
    opts = opts || {};
    const headers = new Headers(opts.headers || {});
    headers.set("Cache-Control","no-store");
    headers.set("Pragma","no-cache");
    headers.set("Expires","0");
    const res = await fetch(url, { ...opts, cache: "no-store", headers });
    if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  }

  function clamp(v, lo, hi){
    v = Number(v);
    if(!Number.isFinite(v)) v = lo;
    return Math.max(lo, Math.min(hi, v));
  }

  function normType(t){
    t = String(t||"").trim();
    if(!t) return "calm";
    if(!TYPES.includes(t)) return "calm";
    return t;
  }
  function typeColor(t){ return TYPE_COL[normType(t)] || "#111"; }

  function snapToLevels(v, prev){
    v = clamp(v, 0, 150);
    let best = LEVEL_BUCKETS[0], bestD = Math.abs(v-best.mid);
    for(const b of LEVEL_BUCKETS){
      const d = Math.abs(v - b.mid);
      if(d < bestD){ best=b; bestD=d; }
      else if(d === bestD && prev!=null){
        const prevB = bucketOf(prev);
        if(prevB && prevB.lvl === b.lvl){ best=b; bestD=d; }
      }
    }
    return best.mid;
  }

  function bucketOf(v){
    v = clamp(v,0,150);
    for(const b of LEVEL_BUCKETS){
      if(b.lo <= v && v <= b.hi) return b;
    }
    return LEVEL_BUCKETS[0];
  }

  function quantT(t){
    return Math.round(Number(t) * FPS) / FPS;
  }

  function sortCurve(){ curve.sort((a,b)=>a.t-b.t); }

  function normalizeCurveEndpoints(){
    if(!duration) return;
    if(!curve || curve.length<2){
      const v = snapToLevels(68);
      curve = [
        {t:0, type:"calm", value:v},
        {t:duration, type:"calm", value:v},
      ];
    }
    sortCurve();
    curve[0].t = 0;
    curve[curve.length-1].t = duration;
  }

  function ensureWave(){
    return !!(wave && duration!=null);
  }

  function overlayRect(){
    return document.getElementById('overlay').getBoundingClientRect();
  }

  function xToT(x){
    const r = overlayRect();
    return clamp((x / r.width) * duration, 0, duration);
  }
  function tToX(t){
    const r = overlayRect();
    return (t / duration) * r.width;
  }
  function yToV(y){
    const r = overlayRect();
    return clamp(150 - (y / r.height) * 150, 0, 150);
  }
  function vToY(v){
    const r = overlayRect();
    return ((150 - v) / 150) * r.height;
  }

  function typeAt(t){
    if(!curve || curve.length<2) return "calm";
    for(let i=0;i<curve.length-1;i++){
      if(curve[i].t <= t && t < curve[i+1].t) return normType(curve[i].type);
    }
    return normType(curve[curve.length-2].type);
  }

  function insertCurvePoint(t, v, ty){
    t = quantT(t);
    v = snapToLevels(v);
    ty = normType(ty);

    for(let i=0;i<curve.length;i++){
      if(Math.abs(curve[i].t - t) < (0.5 / FPS)){
        curve[i].t = t;
        curve[i].value = v;
        curve[i].type = ty;
        normalizeCurveEndpoints();
        return;
      }
    }
    curve.push({t, value:v, type:ty});
    normalizeCurveEndpoints();
  }

  function deletePoint(idx){
    if(!curve || curve.length<3) return false;
    if(idx <= 0) return false;
    if(idx >= curve.length-1) return false;
    curve.splice(idx,1);
    selectedIndex = null;
    normalizeCurveEndpoints();
    return true;
  }

  function applyTypeToInterval(t0, t1, ty){
    ty = normType(ty);
    for(let i=0;i<curve.length-1;i++){
      if(curve[i].t >= t1) continue;
      if(curve[i+1].t <= t0) continue;
      curve[i].type = ty;
    }
    draw();
    saveLabel().catch(err=>setErr(String(err)));
  }

  function transitionFrames(){
    // internal boundaries only (exclude t=0 and t=duration)
    if(!curve || curve.length<3) return [];
    const out = [];
    for(let i=1;i<curve.length-1;i++){
      out.push(Math.round(curve[i].t * FPS));
    }
    return out;
  }

  function totalFrames(){
    if(duration==null) return 0;
    return Math.max(1, Math.round(duration * FPS));
  }

  function updateHeader(){
    if(curIndex<0 || curIndex>=files.length){
      elName.textContent = "No file";
      elFps.textContent = "-";
      elDur.textContent = "-";
      elPtCount.textContent = "0";
      elSegInfo.textContent = "segment: -";
      elCount.textContent = "0";
      elDone.textContent = "done:0";
      elKpi.textContent = "";
      return;
    }
    const f = files[curIndex];
    elName.textContent = `${f.wav} ${f.labeled? "(labeled)" : ""}`;
    elFps.textContent = String(FPS);
    elDur.textContent = (duration!=null) ? duration.toFixed(2) : "-";
    elPtCount.textContent = String(curve?.length ?? 0);

    elCount.textContent = String(files.length);
    const doneCount = files.filter(x=>x.labeled).length;
    elDone.textContent = `done:${doneCount}`;

    if(hoveredSeg!=null && hoveredSeg>=0 && curve.length>=2){
      const t0 = curve[hoveredSeg].t;
      const t1 = curve[hoveredSeg+1].t;
      elSegInfo.textContent = `segment: #${hoveredSeg} ${normType(curve[hoveredSeg].type)}  [${t0.toFixed(3)}, ${t1.toFixed(3)})`;
    } else if(selectedSeg!=null && selectedSeg>=0 && curve.length>=2){
      const t0 = curve[selectedSeg].t;
      const t1 = curve[selectedSeg+1].t;
      elSegInfo.textContent = `segment: #${selectedSeg} ${normType(curve[selectedSeg].type)}  [${t0.toFixed(3)}, ${t1.toFixed(3)})`;
    } else {
      elSegInfo.textContent = `segment: -`;
    }

    const hopFps = DEFAULT_SAMPLE_RATE / DEFAULT_HOP_SAMPLES; // 100
    const tf = totalFrames();
    const trans = transitionFrames();

    elKpi.innerHTML = `
      <span>train_sr=${DEFAULT_SAMPLE_RATE}</span>
      <span>hop=${DEFAULT_HOP_SAMPLES} samples (≈${(1000/hopFps).toFixed(1)}ms)</span>
      <span>ui_fps=${FPS}</span>
      <span>total_frames=${tf}</span>
      <span>transition_frames=[${trans.join(",")}]</span>
    `;
  }

  function renderList(){
    elList.innerHTML = "";
    elCount.textContent = String(files.length);
    const doneCount = files.filter(x=>x.labeled).length;
    elDone.textContent = `done:${doneCount}`;

    files.forEach((f, i)=>{
      const li = document.createElement('li');
      li.className = "item" + (i===curIndex ? " active" : "");
      const ok = f.labeled;
      li.innerHTML = `
        <div>${f.wav}</div>
        <div class="meta">
          <span class="pill ${ok?"ok":"no"}">${ok?"labeled":"todo"}</span>
          <span class="pill">fps=${f.fps ?? FPS}</span>
        </div>
      `;
      li.onclick = ()=>loadIndex(i);
      elList.appendChild(li);
    });
  }

  function destroyWave(){
    if(wave){
      try{ wave.destroy(); }catch(_){}
      wave=null;
    }
    svg.innerHTML="";
    duration=null;
    draggingHandle=null;
  }

  function draw(){
    svg.innerHTML = "";
    if(!ensureWave()) return;

    const r = overlayRect();
    const w=r.width, h=r.height;

    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x","0"); bg.setAttribute("y","0");
    bg.setAttribute("width",String(w)); bg.setAttribute("height",String(h));
    bg.setAttribute("fill","rgba(0,0,0,0.02)");
    svg.appendChild(bg);

    // dashed level guides
    for(const b of LEVEL_BUCKETS){
      const y = vToY(b.mid);
      const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
      ln.setAttribute("x1","0"); ln.setAttribute("x2",String(w));
      ln.setAttribute("y1",String(y)); ln.setAttribute("y2",String(y));
      ln.setAttribute("stroke","rgba(0,0,0,0.18)");
      ln.setAttribute("stroke-dasharray","4 4");
      svg.appendChild(ln);

      const tx = document.createElementNS("http://www.w3.org/2000/svg","text");
      tx.setAttribute("x","4");
      tx.setAttribute("y",String(y-2));
      tx.setAttribute("font-size","11");
      tx.setAttribute("fill","rgba(0,0,0,0.45)");
      tx.style.pointerEvents = "none";
      tx.textContent = `L${b.lvl}`;
      svg.appendChild(tx);
    }

    // segments render
    if(curve && curve.length>=2){
      for(let i=0;i<curve.length-1;i++){
        const t0 = curve[i].t, t1 = curve[i+1].t;
        const v  = curve[i].value;
        const ty = normType(curve[i].type);

        const ln = document.createElementNS("http://www.w3.org/2000/svg","line");
        ln.setAttribute("x1", String(tToX(t0)));
        ln.setAttribute("y1", String(vToY(v)));
        ln.setAttribute("x2", String(tToX(t1)));
        ln.setAttribute("y2", String(vToY(v)));
        ln.setAttribute("stroke", typeColor(ty));
        ln.setAttribute("stroke-width", (selectedSeg===i) ? "5" : "3");
        ln.setAttribute("stroke-linecap","round");
        ln.style.pointerEvents = "none";
        svg.appendChild(ln);

        const mx = (tToX(t0) + tToX(t1))/2;
        const my = vToY(v) - 8;
        const label = document.createElementNS("http://www.w3.org/2000/svg","text");
        label.setAttribute("x", String(mx));
        label.setAttribute("y", String(my));
        label.setAttribute("text-anchor","middle");
        label.setAttribute("font-size","10");
        label.setAttribute("fill", "rgba(0,0,0,0.6)");
        label.style.pointerEvents = "none";
        label.textContent = ty;
        svg.appendChild(label);

        const v2 = curve[i+1].value;
        const j = document.createElementNS("http://www.w3.org/2000/svg","line");
        j.setAttribute("x1", String(tToX(t1)));
        j.setAttribute("y1", String(vToY(v)));
        j.setAttribute("x2", String(tToX(t1)));
        j.setAttribute("y2", String(vToY(v2)));
        j.setAttribute("stroke","rgba(0,0,0,0.25)");
        j.setAttribute("stroke-width","1");
        j.style.pointerEvents = "none";
        svg.appendChild(j);
      }
    }

    // hit target polyline
    const stepPts = [];
    if(curve && curve.length){
      stepPts.push({t:curve[0].t, v:curve[0].value});
      for(let i=1;i<curve.length;i++){
        stepPts.push({t:curve[i].t, v:curve[i-1].value});
        stepPts.push({t:curve[i].t, v:curve[i].value});
      }
    }
    const pts = stepPts.map(p=>`${tToX(p.t)},${vToY(p.v)}`).join(" ");

    const plHit = document.createElementNS("http://www.w3.org/2000/svg","polyline");
    plHit.setAttribute("points", pts);
    plHit.setAttribute("fill","none");
    plHit.setAttribute("stroke","rgba(0,0,0,0)");
    plHit.setAttribute("stroke-width","14");
    plHit.style.pointerEvents = "stroke";
    plHit.style.cursor = "pointer";

    plHit.addEventListener("pointermove", (ev)=>{
      const o = overlayRect();
      const x = ev.clientX - o.left;
      const t = xToT(x);
      let seg = -1;
      for(let i=0;i<curve.length-1;i++){
        if(curve[i].t <= t && t < curve[i+1].t){ seg=i; break; }
      }
      hoveredSeg = (seg>=0) ? seg : null;
      updateHeader();
    });
    plHit.addEventListener("pointerleave", ()=>{
      hoveredSeg = null;
      updateHeader();
    });

    plHit.addEventListener("click", (ev)=>{
      const o = overlayRect();
      const x = ev.clientX - o.left;
      const t = xToT(x);
      let seg = -1;
      for(let i=0;i<curve.length-1;i++){
        if(curve[i].t <= t && t < curve[i+1].t){ seg=i; break; }
      }
      if(seg < 0) return;
      selectedSeg = seg;
      applyTypeToInterval(curve[seg].t, curve[seg+1].t, normType(segTypeEl.value));
      ev.preventDefault();
    });

    svg.appendChild(plHit);

    // handles (upper/lower at jumps)
    const handles = [];
    if(curve && curve.length>=2){
      const n = curve.length;
      handles.push({ boundaryIdx: 0, curveIdxValue: 0, role: "start", x: tToX(curve[0].t), y: vToY(curve[0].value) });

      for(let i=1;i<n-1;i++){
        handles.push({ boundaryIdx: i, curveIdxValue: i-1, role: "lower", x: tToX(curve[i].t), y: vToY(curve[i-1].value) });
        handles.push({ boundaryIdx: i, curveIdxValue: i,   role: "upper", x: tToX(curve[i].t), y: vToY(curve[i].value) });
      }

      handles.push({ boundaryIdx: n-1, curveIdxValue: n-2, role: "end", x: tToX(curve[n-1].t), y: vToY(curve[n-2].value) });
    }

    handles.forEach((h)=>{
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(h.x));
      c.setAttribute("cy", String(h.y));
      c.setAttribute("r", "6");
      c.setAttribute("fill", (h.role==="upper" || h.role==="start") ? "#fff" : "rgba(255,255,255,0.75)");
      const canSelect = (h.boundaryIdx > 0 && h.boundaryIdx < curve.length-1);
      c.setAttribute("stroke", (canSelect && selectedIndex===h.boundaryIdx) ? "#d00" : "#111");
      c.setAttribute("stroke-width", "1.5");
      c.style.cursor = "grab";
      c.style.pointerEvents = "all";

      c.addEventListener("mousedown", (ev)=>{
        ev.preventDefault(); ev.stopPropagation();
        draggingHandle = { boundaryIdx: h.boundaryIdx, curveIdxValue: h.curveIdxValue, role: h.role };
        selectedIndex = canSelect ? h.boundaryIdx : null;
        selectedSeg = null;

        const o = overlayRect();
        const lx = ev.clientX - o.left;
        const ly = ev.clientY - o.top;
        dragOffset.dx = lx - h.x;
        dragOffset.dy = ly - h.y;
      });

      c.addEventListener("click", (ev)=>{
        if(ev.altKey && canSelect){
          ev.preventDefault(); ev.stopPropagation();
          if(deletePoint(h.boundaryIdx)){
            draw();
            saveLabel().catch(err=>setErr(String(err)));
          }
          return;
        }
        selectedIndex = canSelect ? h.boundaryIdx : null;
        draw();
      });

      svg.appendChild(c);
    });

    updateHeader();
  }

  async function loadFiles(){
    setErr("");
    files = await fetchJSON('/api/files');
    renderList();
    const firstUnlabeled = files.findIndex(f=>!f.labeled);
    await loadIndex(firstUnlabeled>=0 ? firstUnlabeled : (files.length?0:-1));
  }

  async function loadIndex(i){
    if(i<0 || i>=files.length){
      curIndex=-1;
      destroyWave();
      updateHeader();
      return;
    }
    curIndex=i;
    renderList();
    destroyWave();
    setErr("");

    const wav = files[curIndex].wav;
    FPS = Number(files[curIndex].fps || FPS);
    fpsInput.value = String(FPS);

    const audioUrl = `/audio/${encodeURIComponent(wav)}`;
    try {
      const head = await fetch(audioUrl, { method: 'HEAD', cache: 'no-store', headers: { 'Cache-Control':'no-store', 'Pragma':'no-cache', 'Expires':'0' } });
      if(!head.ok) throw new Error(`${head.status} ${head.statusText}`);
    } catch (e) {
      setErr(`Audio load failed: ${audioUrl}  (${e})`);
      return;
    }

    wave = WaveSurfer.create({
      container:'#wave',
      height:160,
      waveColor:'#cfe7ff',
      progressColor:'#5aa6ff',
      cursorColor:'#111',
      url: audioUrl,
      normalize:true,
      backend:'WebAudio',
      fetchParams: { cache: 'no-store', headers: { 'Cache-Control':'no-store', 'Pragma':'no-cache', 'Expires':'0' } }
    });

    wave.on('error', (e)=>setErr(`WaveSurfer error: ${e}`));

    wave.on('ready', async ()=>{
      duration = wave.getDuration();

      const lbl = await fetchJSON(`/api/label/${encodeURIComponent(wav)}`);
      curve = Array.isArray(lbl.curve) ? lbl.curve : [];
      if(lbl.fps){
        FPS = Number(lbl.fps);
        fpsInput.value = String(FPS);
      }
      textBox.value = (typeof lbl.text === "string") ? lbl.text : (lbl.text ?? "");

      if(!curve || curve.length<2){
        const v = snapToLevels(68);
        curve = [
          {t:0, type:"calm", value:v},
          {t:duration, type:"calm", value:v},
        ];
      }
      normalizeCurveEndpoints();
      draw();
    });

    updateHeader();
  }

  async function saveLabel(){
    if(curIndex<0) return;
    const wav = files[curIndex].wav;

    FPS = Number(fpsInput.value || FPS);
    files[curIndex].fps = FPS;

    const payload = {
      wav,
      fps: FPS,
      duration: duration,
      curve: curve,
      text: textBox.value || "",
      // 同时把帧信息也存进去（后端仍会在 export 时重新计算，双保险）
      total_frames: totalFrames(),
      transition_frames: transitionFrames(),
    };
    await fetchJSON('/api/save', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    });
    files[curIndex].labeled = true;
    renderList();
    updateHeader();
  }

  async function generate(){
    if(curIndex<0) return;
    const wav = files[curIndex].wav;

    FPS = Number(fpsInput.value || FPS);
    files[curIndex].fps = FPS;

    const resp = await fetchJSON('/api/generate', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        wav,
        fps: FPS,
        duration: duration,
        base: normType(segTypeEl.value),
        triggers: []
      })
    });

    if(resp && Array.isArray(resp.curve)){
      curve = resp.curve;
      normalizeCurveEndpoints();
      draw();
      await saveLabel();
    }
  }

  function exportJSON(){
    if(curIndex<0) return;
    const wav = files[curIndex].wav;
    const out = {
      wav,
      fps: FPS,
      duration,
      curve,
      text: textBox.value || "",
      total_frames: totalFrames(),
      transition_frames: transitionFrames(),
      sample_rate: DEFAULT_SAMPLE_RATE,
      hop_samples: DEFAULT_HOP_SAMPLES,
      hop_fps: DEFAULT_SAMPLE_RATE / DEFAULT_HOP_SAMPLES,
    };

    const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = wav.replace(/\.wav$/,'') + '.json';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // Controls
  document.getElementById('btnReload').addEventListener('click', ()=>loadFiles().catch(err=>setErr(String(err))));
  document.getElementById('btnSave').addEventListener('click', ()=>saveLabel().catch(err=>setErr(String(err))));
  document.getElementById('btnPrev').addEventListener('click', ()=>loadIndex(Math.max(0, curIndex-1)).catch(err=>setErr(String(err))));
  document.getElementById('btnNext').addEventListener('click', ()=>loadIndex(Math.min(files.length-1, curIndex+1)).catch(err=>setErr(String(err))));
  document.getElementById('btnPlay').addEventListener('click', ()=>{ if(wave) wave.playPause(); });
  document.getElementById('btnExport').addEventListener('click', exportJSON);
  document.getElementById('btnGenerate').addEventListener('click', ()=>generate().catch(err=>setErr(String(err))));

  fpsInput.addEventListener('change', ()=>{
    FPS = Number(fpsInput.value || FPS);
    updateHeader();
    draw();
  });

  window.onkeydown = (ev)=>{
    if(ev.code==="Space"){
      ev.preventDefault();
      if(wave) wave.playPause();
    }
    if(ev.key==="ArrowLeft"){
      ev.preventDefault();
      if(curIndex>0) loadIndex(curIndex-1).catch(err=>setErr(String(err)));
    }
    if(ev.key==="ArrowRight"){
      ev.preventDefault();
      if(curIndex<files.length-1) loadIndex(curIndex+1).catch(err=>setErr(String(err)));
    }
    if(ev.key==="s" || ev.key==="S"){
      ev.preventDefault();
      saveLabel().catch(err=>setErr(String(err)));
    }
    if(ev.key==="Delete" || ev.key==="Backspace"){
      if(selectedIndex!=null){
        if(deletePoint(selectedIndex)){
          draw();
          saveLabel().catch(err=>setErr(String(err)));
        }
      }
    }
  };

  window.onmousemove = (ev)=>{
    if(draggingHandle==null) return;
    if(!ensureWave()) return;

    const { boundaryIdx, curveIdxValue } = draggingHandle;
    const o = overlayRect();
    const lx = ev.clientX - o.left - dragOffset.dx;
    const ly = ev.clientY - o.top - dragOffset.dy;

    // shared boundary time
    let t = quantT(xToT(lx));
    const eps = 1 / FPS;

    if(boundaryIdx <= 0){
      t = 0;
    } else if(boundaryIdx >= curve.length-1){
      t = duration;
    } else {
      const tMin = curve[boundaryIdx-1].t + eps;
      const tMax = curve[boundaryIdx+1].t - eps;
      t = clamp(t, tMin, tMax);
      curve[boundaryIdx].t = t;
    }

    // snapped vertical value
    let v = snapToLevels(yToV(ly), curve[curveIdxValue]?.value);
    curve[curveIdxValue].value = v;

    normalizeCurveEndpoints();
    draw();
  };

  window.onmouseup = ()=>{
    if(draggingHandle!=null){
      draggingHandle=null;
      saveLabel().catch(err=>setErr(String(err)));
    }
  };

  // Right click: add point
  const overlay = document.getElementById('overlay');
  overlay.addEventListener("contextmenu", (ev)=>{ ev.preventDefault(); });

  overlay.addEventListener("mousedown", (ev)=>{
    if(!ensureWave()) return;
    if(ev.button !== 2) return;

    const o = overlayRect();
    const x = ev.clientX - o.left;
    const y = ev.clientY - o.top;

    const t = quantT(xToT(x));
    const v = snapToLevels(yToV(y));
    insertCurvePoint(t, v, typeAt(t));
    draw();
    saveLabel().catch(err=>setErr(String(err)));
    ev.preventDefault();
  });

  loadFiles().catch(err=>setErr(String(err)));
</script>
</body>
</html>
