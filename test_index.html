<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Speech2Emotion - Label vs Pred Compare</title>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    .left { border-right: 1px solid #ddd; overflow: auto; }
    .right { padding: 14px 18px; overflow:auto; }

    .hdr { padding: 12px 12px; border-bottom: 1px solid #eee; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .hdr b { font-size: 14px; }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; background:#f3f3f3; display:inline-block; }
    .pill.ok { background:#e6f7e6; }
    .pill.no { background:#ffecec; }
    .pill.pred { background:#eef6ff; }
    .pill.lbl { background:#fff7e6; }

    .list { padding: 0; margin: 0; list-style: none; }
    .item { padding: 10px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
    .item:hover { background: #fafafa; }
    .item.active { background: #eef6ff; }
    .meta { font-size: 12px; color: #666; margin-top: 6px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .muted { color:#666; }
    .danger { color:#b00020; }
    button, select, input { font: inherit; }
    select, input { padding:6px 8px; border:1px solid #ddd; border-radius: 10px; }
    button { padding: 8px 10px; border: 1px solid #ccc; background:#fff; border-radius: 10px; cursor:pointer; }
    button:hover { background:#fafafa; }

    #waveBox { border: 1px solid #ddd; border-radius: 12px; padding: 10px; position: relative; margin-top:10px; }
    #wave { position: relative; }
    #overlay {
      position:absolute; left:10px; right:10px;
      top:10px;
      height:180px;
      z-index: 5;
      pointer-events: none;
    }
    #overlay svg { width:100%; height:100%; display:block; }

    .panel { margin-top: 10px; border:1px solid #eee; border-radius: 12px; padding: 10px; }
    .legend { display:flex; flex-wrap:wrap; gap:10px; margin-top:8px; }
    .legend .it { display:flex; align-items:center; gap:6px; font-size:12px; color: rgba(0,0,0,0.75); }
    .legend .dot { width:10px; height:10px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,0.25); }
    .hint { font-size: 12px; color:#666; line-height: 1.5; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
           font-size: 12px; border: 1px solid #ddd; padding: 2px 6px; border-radius: 6px; background:#fafafa; }

    .topbar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .sep { width:1px; height:18px; background:#ddd; display:inline-block; }

    .infoGrid { display:grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap:8px; margin-top:8px; }
    .card { border:1px solid #eee; border-radius: 10px; padding:8px 10px; }
    .card .k { font-size:12px; color:#666; }
    .card .v { font-size:14px; font-weight:600; margin-top:2px; }

    @media (max-width: 980px){
      .wrap { grid-template-columns: 1fr; }
      .left { height: 40vh; }
      .right { height: 60vh; }
      .infoGrid{ grid-template-columns: repeat(3, minmax(0,1fr)); }
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="hdr">
      <b>Files</b>
      <span class="pill" id="countPill">0</span>
      <span class="pill lbl" id="lblPill">labeled: 0</span>
      <span class="pill pred" id="predPill">pred: 0</span>
    </div>
    <ul class="list" id="fileList"></ul>
  </div>

  <div class="right">
    <div class="topbar">
      <div><b id="curName">No file</b></div>
      <span class="pill lbl">Label=实线</span>
      <span class="pill pred">Pred=虚线</span>
      <span class="sep"></span>
      <div class="muted">fps: <b id="fps">30</b></div>
      <div class="muted">duration(s): <b id="dur">—</b></div>
      <div class="muted">frames: <b id="nFrames">—</b></div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btnPlay">Play/Pause <span class="kbd">Space</span></button>
      <button id="btnPrev">Prev <span class="kbd">P</span></button>
      <button id="btnNext">Next <span class="kbd">N</span></button>

      <span class="sep"></span>
      <span class="muted">bnd tol(frames)</span>
      <input id="tol" type="number" min="0" max="10" step="1" value="1" style="width:70px;" />
      <button id="btnRecalc">Recalc</button>

      <span class="sep"></span>
      <button id="btnOpenAnn" title="打开标注器(7860)当前 wav">Open Annotater</button>
    </div>

    <div id="waveBox">
      <div id="wave"></div>
      <div id="overlay"><svg id="svg"></svg></div>
    </div>

    <div class="infoGrid">
      <div class="card">
        <div class="k">Label segments</div>
        <div class="v" id="lblSeg">—</div>
      </div>
      <div class="card">
        <div class="k">Pred segments</div>
        <div class="v" id="predSeg">—</div>
      </div>
      <div class="card">
        <div class="k">Label boundaries</div>
        <div class="v" id="lblBnd">—</div>
      </div>
      <div class="card">
        <div class="k">Pred boundaries</div>
        <div class="v" id="predBnd">—</div>
      </div>
      <div class="card">
        <div class="k">bnd Precision</div>
        <div class="v" id="pBnd">—</div>
      </div>
      <div class="card">
        <div class="k">bnd Recall / F1</div>
        <div class="v" id="rfBnd">—</div>
      </div>
    </div>

    <div class="panel">
      <div class="hint">
        <b>说明</b>：
        <ul>
          <li>同屏叠加：Label（实线）与 Pred（虚线）。</li>
          <li>竖虚线：边界（Label 用淡橙，Pred 用淡蓝）。</li>
          <li>右侧 bnd 指标：按 “预测边界与标注边界在 ±tol 帧内算匹配” 计算。</li>
        </ul>
      </div>

      <div class="legend" id="legend"></div>
      <div class="danger" id="err" style="margin-top:8px"></div>
    </div>

    <div class="panel">
      <div class="hint" id="hoverInfo">Hover: —</div>
    </div>
  </div>
</div>

<script>
  const FPS_DEFAULT = 30;
  const VALUE_MIN = 0;
  const VALUE_MAX = 150;

  const TYPES = ["happy","sad","angry","fear","calm","confused","action"];

  let files = [];
  let curIndex = -1;
  let wave = null;
  let duration = 0;

  // unified timeline fps for frame-based metrics/hover/boundaries
  // IMPORTANT: do NOT use label fps here (label may be 100); use pred fps (typically 30)
  let fpsCommon = FPS_DEFAULT;

  // current objects
  let lblObj = null;
  let predObj = null;

  // derived (for drawing)
  let lblSegs = [];
  let predSegs = [];
  let lblBnds = [];
  let predBnds = [];

  // DOM
  const elList = document.getElementById('fileList');
  const elName = document.getElementById('curName');
  const elFps = document.getElementById('fps');
  const elDur = document.getElementById('dur');
  const elNFrames = document.getElementById('nFrames');
  const elErr = document.getElementById('err');
  const elCount = document.getElementById('countPill');
  const elLbl = document.getElementById('lblPill');
  const elPred = document.getElementById('predPill');

  const svg = document.getElementById('svg');
  const btnPlay = document.getElementById('btnPlay');
  const btnPrev = document.getElementById('btnPrev');
  const btnNext = document.getElementById('btnNext');
  const btnOpenAnn = document.getElementById('btnOpenAnn');
  const tolInp = document.getElementById('tol');
  const btnRecalc = document.getElementById('btnRecalc');

  const elLblSeg = document.getElementById('lblSeg');
  const elPredSeg = document.getElementById('predSeg');
  const elLblBnd = document.getElementById('lblBnd');
  const elPredBnd = document.getElementById('predBnd');
  const elPBnd = document.getElementById('pBnd');
  const elRFBnd = document.getElementById('rfBnd');
  const elHoverInfo = document.getElementById('hoverInfo');

  function setErr(msg){ elErr.textContent = msg || ""; }

  async function fetchJSON(url, opts){
    const res = await fetch(url, opts);
    if(!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  }

  function clamp(v, lo, hi){
    v = Number(v);
    if(!Number.isFinite(v)) v = lo;
    return Math.max(lo, Math.min(hi, v));
  }

  function typeColor(ty){
    const map = {
      happy: "#ffb020",
      sad: "#3b82f6",
      angry: "#ef4444",
      fear: "#8b5cf6",
      calm: "#10b981",
      confused: "#a855f7",
      action: "#111827",
    };
    return map[ty] || "#999";
  }

  function renderLegend(){
    const lg = document.getElementById("legend");
    lg.innerHTML = "";
    for(const ty of TYPES){
      const it = document.createElement("div");
      it.className = "it";
      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = typeColor(ty);
      it.appendChild(dot);
      const tx = document.createElement("span");
      tx.textContent = ty;
      it.appendChild(tx);
      lg.appendChild(it);
    }
  }
  renderLegend();

  function timeToX(t, w){
    if(duration <= 1e-6) return 0;
    return (t / duration) * w;
  }
  function valueToY(v, h){
    v = clamp(v, VALUE_MIN, VALUE_MAX);
    const r = (v - VALUE_MIN) / (VALUE_MAX - VALUE_MIN + 1e-9);
    return (1 - r) * h;
  }

  function quantizeToFrame(t, fps){
    return Math.max(0, Math.round(t * fps));
  }

  function segmentsFromCurve(curve, fps){
    const segs = [];
    if(!curve || curve.length < 2) return segs;
    for(let i=0;i<curve.length-1;i++){
      const a = curve[i], b = curve[i+1];
      const t0 = clamp(a.t, 0, duration);
      const t1 = clamp(b.t, 0, duration);
      if(t1 <= t0) continue;
      const ty = (TYPES.includes(a.type) ? a.type : "calm");
      const val = Number(a.value ?? 5);
      const f0 = quantizeToFrame(t0, fps);
      const f1 = quantizeToFrame(t1, fps);
      segs.push({t0, t1, f0, f1, type: ty, value: val});
    }
    return segs;
  }

  function boundariesFromSegments(segs){
    const b = [];
    for(let i=1;i<segs.length;i++){
      b.push(segs[i].f0);
    }
    return b;
  }

  function preferPredSegments(obj, fpsCommonLocal){
    // pred.segments are in frame indices of obj.fps; convert to seconds, then re-quantize into fpsCommon
    const fpsPred = Number(obj?.fps || FPS_DEFAULT);
    const fpsC = Number(fpsCommonLocal || fpsCommon || FPS_DEFAULT);
    if(obj && Array.isArray(obj.segments) && obj.segments.length){
      const segs = [];
      for(const s of obj.segments){
        const f0p = Number(s.f0||0), f1p = Number(s.f1||0);
        const t0 = f0p / fpsPred;
        const t1 = f1p / fpsPred;
        const f0 = quantizeToFrame(t0, fpsC);
        const f1 = quantizeToFrame(t1, fpsC);
        segs.push({ t0, t1, f0, f1, type: s.type || "calm", value: Number(s.value ?? 5) });
      }
      return segs;
    }
    return null;
  }

  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }

  function drawGrid(w, h){
    const levels = [0,1,2,3,4,5];
    for(const lv of levels){
      const v = (lv/5) * VALUE_MAX;
      const y = valueToY(v, h);
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1","0");
      line.setAttribute("x2", String(w));
      line.setAttribute("y1", String(y));
      line.setAttribute("y2", String(y));
      line.setAttribute("stroke", "rgba(0,0,0,0.10)");
      line.setAttribute("stroke-dasharray","6 6");
      svg.appendChild(line);
    }
  }

  function drawBoundaries(bnds, fps, w, h, stroke, dash){
    for(const f of bnds){
      const t = f / fps;
      const x = timeToX(t, w);
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", String(x));
      line.setAttribute("x2", String(x));
      line.setAttribute("y1", "0");
      line.setAttribute("y2", String(h));
      line.setAttribute("stroke", stroke);
      line.setAttribute("stroke-width","1.5");
      line.setAttribute("stroke-dasharray", dash);
      svg.appendChild(line);
    }
  }

  function drawSegments(segs, w, h, style){
    // style: {dash, opacity, width}
    const dash = style?.dash ?? "";
    const op = style?.opacity ?? 1.0;
    const sw = style?.width ?? 3;

    for(let i=0;i<segs.length;i++){
      const s = segs[i];
      const x0 = timeToX(s.t0, w);
      const x1 = timeToX(s.t1, w);
      const y = valueToY(s.value, h);
      const col = typeColor(s.type);

      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", String(x0));
      line.setAttribute("x2", String(x1));
      line.setAttribute("y1", String(y));
      line.setAttribute("y2", String(y));
      line.setAttribute("stroke", col);
      line.setAttribute("stroke-width", String(sw));
      line.setAttribute("stroke-linecap","round");
      if(dash) line.setAttribute("stroke-dasharray", dash);
      line.setAttribute("opacity", String(op));
      svg.appendChild(line);

      if(i < segs.length - 1){
        const next = segs[i+1];
        const y2 = valueToY(next.value, h);
        const vline = document.createElementNS("http://www.w3.org/2000/svg","line");
        vline.setAttribute("x1", String(x1));
        vline.setAttribute("x2", String(x1));
        vline.setAttribute("y1", String(y));
        vline.setAttribute("y2", String(y2));
        vline.setAttribute("stroke", col);
        vline.setAttribute("stroke-width", String(Math.max(2, sw-1)));
        if(dash) vline.setAttribute("stroke-dasharray", dash);
        vline.setAttribute("opacity", String(op));
        svg.appendChild(vline);
      }
    }
  }

  function redraw(){
    clearSVG();
    const rect = document.getElementById("overlay").getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);

    const fps = Number(fpsCommon || FPS_DEFAULT);

    drawGrid(w, h);

    // boundaries
    // label: orange-ish, pred: blue-ish
    drawBoundaries(lblBnds, fps, w, h, "rgba(255,176,32,0.35)", "5 6");
    drawBoundaries(predBnds, fps, w, h, "rgba(59,130,246,0.30)", "3 6");

    // curves
    // label solid (on top slightly)
    drawSegments(predSegs, w, h, {dash:"7 6", opacity:0.75, width:3});
    drawSegments(lblSegs,  w, h, {dash:"",     opacity:0.95, width:3.5});
  }

  function renderList(){
    elList.innerHTML = "";
    let nLbl = 0, nPred = 0;

    files.forEach((f, idx) => {
      if(f.labeled) nLbl++;
      if(f.predicted) nPred++;

      const li = document.createElement('li');
      li.className = 'item' + (idx===curIndex ? ' active':'');
      li.onclick = () => loadIndex(idx);

      const title = document.createElement('div');
      title.textContent = f.wav;
      li.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'meta';

      const p1 = document.createElement('span');
      p1.className = 'pill ' + (f.labeled ? 'ok lbl':'no lbl');
      p1.textContent = f.labeled ? 'labeled' : 'no label';
      meta.appendChild(p1);

      const p2 = document.createElement('span');
      p2.className = 'pill ' + (f.predicted ? 'ok pred':'no pred');
      p2.textContent = f.predicted ? 'pred' : 'no pred';
      meta.appendChild(p2);

      li.appendChild(meta);
      elList.appendChild(li);
    });

    elCount.textContent = String(files.length);
    elLbl.textContent = `labeled: ${nLbl}`;
    elPred.textContent = `pred: ${nPred}`;
  }

  async function initWaveIfNeeded(){
    if(wave) return;
    wave = WaveSurfer.create({
      container: '#wave',
      height: 180,
      normalize: true,
      cursorWidth: 2,
      barWidth: 0,
      interact: true,
    });

    btnPlay.onclick = () => wave.playPause();
    wave.on('ready', () => {
      duration = wave.getDuration();
      elDur.textContent = duration.toFixed(3);
      redraw();
      recalcBndMetrics();
    });

    // keyboard
    document.addEventListener('keydown', (e) => {
      if(e.code === 'Space'){ e.preventDefault(); wave.playPause(); }
      if(e.key === 'n' || e.key === 'N') loadIndex(curIndex + 1);
      if(e.key === 'p' || e.key === 'P') loadIndex(curIndex - 1);
    });
  }

  function setHoverInfoFromTime(t){
    const fps = Number(fpsCommon || FPS_DEFAULT);
    const f = Math.round(t * fps);

    function findSeg(segs){
      for(const s of segs){
        if(f >= s.f0 && f < s.f1) return s;
      }
      return null;
    }
    const a = findSeg(lblSegs);
    const b = findSeg(predSegs);

    const base = `Hover: t=${t.toFixed(3)}s f=${f}  `;
    const s1 = a ? `Label{${a.type}, v=${Number(a.value).toFixed(1)}, f=[${a.f0},${a.f1})}` : `Label{—}`;
    const s2 = b ? `Pred{${b.type}, v=${Number(b.value).toFixed(1)}, f=[${b.f0},${b.f1})}` : `Pred{—}`;
    elHoverInfo.textContent = base + "  " + s1 + "  " + s2;
  }

  function attachHover(){
    const overlay = document.getElementById("overlay");
    overlay.onmousemove = (ev) => {
      const rect = overlay.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const w = rect.width;
      const t = (duration > 1e-6) ? (x / w) * duration : 0;
      setHoverInfoFromTime(clamp(t, 0, duration));
    };
    overlay.onmouseleave = () => { elHoverInfo.textContent = "Hover: —"; };
  }
  attachHover();

  function uniqSorted(arr){
    const s = new Set(arr.map(x => Number(x)).filter(x => Number.isFinite(x)));
    return Array.from(s).sort((a,b)=>a-b);
  }

  function matchBoundaries(gt, pr, tol){
    // greedy: for each pred, match nearest unmatched gt within tol
    gt = uniqSorted(gt);
    pr = uniqSorted(pr);
    tol = Math.max(0, Number(tol)||0);

    const gtUsed = new Array(gt.length).fill(false);
    let tp = 0;

    for(const p of pr){
      let best = -1;
      let bestDist = 1e9;
      for(let i=0;i<gt.length;i++){
        if(gtUsed[i]) continue;
        const d = Math.abs(gt[i] - p);
        if(d <= tol && d < bestDist){
          bestDist = d;
          best = i;
        }
      }
      if(best >= 0){
        gtUsed[best] = true;
        tp += 1;
      }
    }

    const fp = pr.length - tp;
    const fn = gt.length - tp;
    const prec = (tp + fp) > 0 ? tp / (tp + fp) : 0;
    const rec  = (tp + fn) > 0 ? tp / (tp + fn) : 0;
    const f1   = (prec + rec) > 0 ? (2 * prec * rec) / (prec + rec) : 0;
    return {tp, fp, fn, prec, rec, f1};
  }

  function recalcBndMetrics(){
    const tol = clamp(tolInp.value, 0, 10);
    tolInp.value = String(tol);

    const m = matchBoundaries(lblBnds, predBnds, tol);

    elLblSeg.textContent = String(lblSegs.length);
    elPredSeg.textContent = String(predSegs.length);
    elLblBnd.textContent = String(lblBnds.length);
    elPredBnd.textContent = String(predBnds.length);

    elPBnd.textContent = `${m.prec.toFixed(3)} (tp=${m.tp}, fp=${m.fp})`;
    elRFBnd.textContent = `${m.rec.toFixed(3)} / ${m.f1.toFixed(3)} (fn=${m.fn})`;
  }

  async function loadIndex(idx){
    idx = clamp(idx, 0, files.length-1);
    if(!Number.isFinite(idx)) return;
    curIndex = idx;
    renderList();
    setErr("");

    const f = files[curIndex];
    const wav = f.wav;

    elName.textContent = wav;
    elFps.textContent = String(f.fps || FPS_DEFAULT);

    await initWaveIfNeeded();

    // load label + pred in parallel
    lblObj = null;
    predObj = null;

    const pLbl = fetchJSON(`/api/label/${encodeURIComponent(wav)}`).catch(_=>null);
    const pPred = fetchJSON(`/api/pred/${encodeURIComponent(wav)}`).catch(_=>null);

    [lblObj, predObj] = await Promise.all([pLbl, pPred]);

    // load audio
    try{
      await wave.load(`/audio/${encodeURIComponent(wav)}`);
    }catch(err){
      setErr(`load audio failed: ${err}`);
    }

    // IMPORTANT: label fps may be 100 (annotation resolution). We unify everything to pred fps (typically 30).
    fpsCommon = Number(predObj?.fps || FPS_DEFAULT);
    elFps.textContent = String(fpsCommon);

    // frames & duration (always based on audio duration and fpsCommon)
    elDur.textContent = duration ? duration.toFixed(3) : "—";
    const nFrames = duration ? Math.round(duration * fpsCommon) : 0;
    elNFrames.textContent = String(nFrames);

    // build label segs
    const lblCurve = Array.isArray(lblObj?.curve) ? lblObj.curve : [];
    lblSegs = segmentsFromCurve(lblCurve, fpsCommon);
    if(!lblSegs.length && lblObj && lblObj.wav){
      // allow empty label
      lblSegs = [];
    }

    // build pred segs
    if(predObj){
      const preferred = preferPredSegments(predObj, fpsCommon);
      if(preferred) predSegs = preferred;
      else{
        const predCurve = Array.isArray(predObj?.curve) ? predObj.curve : [];
        predSegs = segmentsFromCurve(predCurve, fpsCommon);
      }
    }else{
      predSegs = [];
    }

    // boundaries
    lblBnds = boundariesFromSegments(lblSegs);
    if(predObj && Array.isArray(predObj.boundaries)){
      // pred boundaries are in pred fps; convert to fpsCommon
      const fpsPred = Number(predObj?.fps || fpsCommon || FPS_DEFAULT);
      predBnds = predObj.boundaries
        .map(x => Number(x))
        .filter(x => Number.isFinite(x))
        .map(fp => quantizeToFrame(fp / fpsPred, fpsCommon));
    }else{
      predBnds = boundariesFromSegments(predSegs);
    }

    // normalize
    lblBnds = uniqSorted(lblBnds);
    predBnds = uniqSorted(predBnds);

    // redraw & metrics
    redraw();
    recalcBndMetrics();

    // open annotater
    btnOpenAnn.onclick = () => {
      window.open(`http://127.0.0.1:7860/?wav=${encodeURIComponent(wav)}`, "_blank");
    };
  }

  async function boot(){
    setErr("");
    try{
      files = await fetchJSON("/api/files");
      renderList();
      if(files.length > 0){
        await loadIndex(0);
      }
    }catch(err){
      setErr(`boot failed: ${err}`);
    }

    btnPrev.onclick = () => loadIndex(curIndex - 1);
    btnNext.onclick = () => loadIndex(curIndex + 1);
    btnRecalc.onclick = () => recalcBndMetrics();
    tolInp.onchange = () => recalcBndMetrics();
  }

  boot();
</script>
</body>
</html>
